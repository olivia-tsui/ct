
// This is a skeleton starter React component generated by Plasmic.
// This file is owned by you, feel free to edit as you see fit.
import * as React from "react";
import {
  PlasmicColors,
  DefaultColorsProps,
} from "./plasmic/color_tool/PlasmicColors";
import { HTMLElementRefOf } from "@plasmicapp/react-web";
import Color from "./Color";
import chroma from "chroma-js";
import { ColorsContext,ConfigUpdateContext } from "./Theme";
import { HomeContext } from "../pages/index";
import { InterpolationMode } from "chroma-js";
import * as Slider from "@radix-ui/react-slider";

export interface ColorsProps extends DefaultColorsProps {
  uploaddata: (data: any) => string[];
  manualAdjusting: "" | "l" | "s";
}

function Colors_(props: ColorsProps, ref: HTMLElementRefOf<"div">) {
  const config = React.useContext(ColorsContext);
  const updateConfig = React.useContext(ConfigUpdateContext);
  const home = React.useContext(HomeContext);

  let shades: string[] = [];
  let names: string[] = [];
  let manualLightAdjustments: number[] = [];
  let manualSaturationAdjustments: number[] = [];
  let [manualAdjustments, setManualAdjustments] = React.useState({
    light: manualLightAdjustments,
    saturation: manualSaturationAdjustments,
  });

  const contrast = (color: string) => {
    let whiteTextContrast = chroma.contrast(color, light);
    let darkTextContrast = chroma.contrast(color, dark);
    return whiteTextContrast > darkTextContrast
      ? `${whiteTextContrast.toFixed(1)}`
      : `${darkTextContrast.toFixed(1)}`;
  };

  let light = chroma(config.baseValue)
    .set("hsl.h", config.lightHueShift)
    .luminance(config.lightLuminance);

  let dark = chroma(config.baseValue)
    .set("hsl.h", config.darkHueShift)
    .luminance(config.darkLuminance);
  if (config.saturation > 0) {
    light = light.saturate(config.saturation);
  } else if (config.saturation < 0) {
    light = light.desaturate(-config.saturation);
  }
  if (config.darkSaturation > 0) {
    dark = dark.saturate(config.darkSaturation);
  } else if (config.darkSaturation < 0) {
    dark = dark.desaturate(-config.darkSaturation);
  }

  let lightScale = chroma
    .scale([config.baseValue, light.hex()])
    .mode(home.mode as InterpolationMode)
    .domain(config.lightDomain)
    .colors(config.stepsLighter + 1);
  let darkScale = chroma
    .scale([config.baseValue, dark.hex()])
    .mode(home.mode as InterpolationMode)
    .domain(config.darkDomain)
    .colors(config.stepsDarker + 1);

  for (let i = lightScale.length - 1; i > 0; i--) {
    let newShade = lightScale[i];
    shades.push(newShade);
    names.push(`L${i}`);
  }
  // add base
  shades.push(config.baseValue);
  names.push("Base");

  for (let i = 1; i < darkScale.length; i++) {
    let newShade = darkScale[i];
    shades.push(newShade);
    names.push(`D${i}`);
  }

  props.uploaddata(JSON.stringify([names, shades]));

  //useState to manage to shade array
  const [thisColor, setThisColor] = React.useState(shades);

  //useEffect for updating the color Array
  React.useEffect(() => {
    
    setThisColor(shades)
  }, [config]);

React.useEffect(()=>{
  props.uploaddata(JSON.stringify([names, thisColor]));
//  updateConfig({...config,manualAdjustments:manualAdjustments})
},[thisColor]);

  return (
    // @ts-ignore
    <PlasmicColors
      root={{
        ref,
      }}
      allColors={{
        props: {
          children: thisColor.map((color, i) => {
            return (
              <Color
                key={i}
                onDark={
                  chroma.contrast(light, thisColor[i]) < 2.5 ? true : false
                }
                color={thisColor[i]}
                name={names[i]}
                hexCode={
                  props.manualAdjusting !== ""
                    ? (
                        chroma(thisColor[i]).get(
                          `hsl.${props.manualAdjusting}`
                        ) * 100
                      ).toFixed(0)
                    : thisColor[i].toUpperCase()
                }
                // @ts-ignore
                contrast={contrast(thisColor[i])}
                isLocked={thisColor[i] === config.baseValue}
                lock={{
                  props: {
                    stroke:
                      chroma.contrast(thisColor[i], "#FFFFFF") < 2.5
                        ? "#000000"
                        : "#ffffff",
                  },
                }}
                darkTextColor={light.hex()}
                lightTextColor={dark.hex()}
                adjustingSaturation={props.manualAdjusting !== ""}
                slider={{
                  props: {
                    children: (
                      <Slider.Root
                        orientation="vertical"
                        value={[
                          chroma(thisColor[i]).get(
                            `hsl.${props.manualAdjusting}`
                          ) * 100,
                        ]}
                        style={{
                          position: "relative",
                          display: "flex",
                          alignItems: "center",
                          flexDirection: "column",
                          width: 40,
                          height: "100%",
                        }}
                        onValueChange={(e) => {
                          if (names[i] === "Base") return;

                          // create a copy of the original state
                          const updatedManualAdjustments = {
                            light: [...manualAdjustments.light],
                            saturation: [...manualAdjustments.saturation],
                          };
                          if (props.manualAdjusting === "s") {
                            // update the value at the nth index of the light array
                            updatedManualAdjustments.saturation[i] = e[0] / 100;
                            // update the state with the modified copy
                            setManualAdjustments(updatedManualAdjustments);
                          } else if (props.manualAdjusting === "l") {
                            // update the value at the nth index of the light array
                            updatedManualAdjustments.light[i] = e[0] / 100;
                            // update the state with the modified copy
                            setManualAdjustments(updatedManualAdjustments);
                          }

                          const updatedColorSets = [...thisColor];
                          if (
                            updatedManualAdjustments.saturation[i] === undefined
                          )
                            updatedManualAdjustments.saturation[i] = chroma(
                              shades[i]
                            ).get("hsl.s");

                          if (updatedManualAdjustments.light[i] === undefined)
                            updatedManualAdjustments.light[i] = chroma(
                              shades[i]
                            ).get("hsl.l");

                          updatedColorSets[i] = chroma(shades[i])
                            .set(
                              `hsl.s`,
                              updatedManualAdjustments.saturation.length > 0
                                ? updatedManualAdjustments.saturation[i]
                                : chroma(shades[i]).get("hsl.s")
                            )
                            .set(
                              `hsl.l`,
                              updatedManualAdjustments.light.length > 0
                                ? updatedManualAdjustments.light[i]
                                : chroma(shades[i]).get("hsl.l")
                            )
                            .hex();

                          // Set the state with the updated items
                          setThisColor(updatedColorSets);
                        }}
                      >
                        <Slider.Track
                          style={{
                            flexGrow: 1,
                            position: "relative",
                            width: 3,
                          }}
                        ></Slider.Track>
                        <Slider.Thumb
                          style={{
                            display: "block",
                            width: 16,
                            height: 16,
                            backgroundColor:
                              chroma.contrast("white", thisColor[i]) < 2.5
                                ? "black"
                                : "white",
                            borderRadius: "99px",
                          }}
                        />
                      </Slider.Root>
                    ),
                  },
                }}
              ></Color>
            );
          }),
        },
      }}
      adjustingSaturation={props.manualAdjusting !== ""}
      {...props}
    />
  );
}

const Colors = React.forwardRef(Colors_);
export default Colors;
